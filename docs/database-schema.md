# Database Schema Documentation

## Overview
This document explains the PostgreSQL database schema and structure of the BugChain Indexer.

**Database**: `bugchain_indexer`
**PostgreSQL Version**: 12+
**Host**: localhost

---

## Table Structure

### addresses Table

Main table that stores all blockchain addresses (contracts and EOAs).

#### Schema
```sql
CREATE TABLE IF NOT EXISTS addresses (
    address TEXT NOT NULL,                -- Ethereum address (0x...)
    code_hash TEXT,                       -- Contract code hash
    contract_name TEXT,                   -- Contract name
    deployed BIGINT,                      -- Deployment timestamp (Unix timestamp)
    last_updated BIGINT,                  -- Last update time
    network TEXT NOT NULL,                -- Network name (ethereum, binance, etc.)
    first_seen BIGINT,                    -- First seen time (Unix timestamp)
    tags TEXT[] DEFAULT '{}',             -- Tag array (EOA, Contract, etc.)
    fund BIGINT DEFAULT 0,                -- Funding amount (USD, no decimals)
    last_fund_updated BIGINT DEFAULT 0,   -- Last fund update time
    name_checked BOOLEAN NOT NULL DEFAULT false,     -- Whether name was checked
    name_checked_at BIGINT NOT NULL DEFAULT 0,       -- Name check time
    PRIMARY KEY (address, network)        -- Composite Primary Key
);
```

#### Indexes

##### Required Indexes (auto-generated by ensureSchema)
```sql
-- Network basic index
CREATE INDEX IF NOT EXISTS idx_addresses_network
  ON addresses(network);

-- Tags GIN index (array search optimization)
CREATE INDEX IF NOT EXISTS idx_addresses_tags_gin
  ON addresses USING GIN(tags);

-- Network + fund composite index
CREATE INDEX IF NOT EXISTS idx_addresses_fund
  ON addresses(network, fund);

-- Network + last_updated index
CREATE INDEX IF NOT EXISTS idx_addresses_last_updated
  ON addresses(network, last_updated);

-- Network + first_seen index (DESC sort optimization)
CREATE INDEX IF NOT EXISTS idx_addresses_first_seen
  ON addresses(network, first_seen DESC);

-- Global first_seen index (excluding EOA)
CREATE INDEX IF NOT EXISTS idx_addresses_first_seen_global
  ON addresses(first_seen DESC NULLS LAST)
  WHERE (tags IS NULL OR NOT 'EOA' = ANY(tags));

-- Network filter index (excluding EOA)
CREATE INDEX IF NOT EXISTS idx_addresses_network_notags
  ON addresses(network)
  WHERE (tags IS NULL OR NOT 'EOA' = ANY(tags));
```

##### Additional Optimization Indexes (recommended for manual creation)
```sql
-- Composite index for API sort optimization
CREATE INDEX IF NOT EXISTS idx_addresses_api_sort_optimal
  ON addresses (fund DESC, deployed DESC, address ASC)
  WHERE (tags IS NULL OR NOT 'EOA' = ANY(tags));

-- Index for address prefix search
CREATE INDEX IF NOT EXISTS idx_addresses_address_prefix
  ON addresses (address text_pattern_ops);
```

#### Data Examples
```sql
-- SafeProxy contract on Gnosis network
{
  address: '0x016847fb16ac68145a64c38afb9695e5fde6c73d',
  contract_name: 'SafeProxy',
  deployed: 1761658860,
  fund: 0,
  network: 'gnosis',
  first_seen: 1761958807,
  tags: null
}

-- EOA address on Ethereum
{
  address: '0x742d35Cc6634C0532925a3b844Bc9e7595f0bEb',
  contract_name: null,
  deployed: null,
  fund: 150000000000000000,
  network: 'ethereum',
  first_seen: 1735123456,
  tags: ['EOA']
}
```

#### Statistics
```sql
-- Check table size
SELECT
  pg_size_pretty(pg_total_relation_size('addresses')) AS total_size,
  pg_size_pretty(pg_relation_size('addresses')) AS table_size,
  pg_size_pretty(pg_total_relation_size('addresses') - pg_relation_size('addresses')) AS index_size;

-- Total row count
SELECT COUNT(*) FROM addresses;
-- Expected: ~270,000+ rows

-- Network statistics
SELECT
  network,
  COUNT(*) AS total_addresses,
  COUNT(CASE WHEN tags && ARRAY['EOA'] THEN 1 END) AS eoa_count,
  COUNT(CASE WHEN contract_name IS NOT NULL THEN 1 END) AS contract_count
FROM addresses
GROUP BY network
ORDER BY total_addresses DESC;
```

### tokens Table

Table for tracking token prices.

#### Schema
```sql
CREATE TABLE IF NOT EXISTS tokens (
    token_address TEXT NOT NULL,
    network TEXT NOT NULL,
    name TEXT,
    symbol TEXT,
    decimals INTEGER,
    price DECIMAL(20, 8),              -- USD price
    price_updated BIGINT,              -- Price update time
    is_valid BOOLEAN DEFAULT true,
    PRIMARY KEY (token_address, network)
);
```

#### Indexes
```sql
CREATE INDEX IF NOT EXISTS idx_tokens_network
  ON tokens(network);

CREATE INDEX IF NOT EXISTS idx_tokens_price_updated
  ON tokens(network, price_updated);
```

---

### token_metadata_cache Table

Token metadata caching table (30-day cache).

#### Schema
```sql
CREATE TABLE IF NOT EXISTS token_metadata_cache (
    network TEXT NOT NULL,
    token_address TEXT NOT NULL,
    symbol TEXT,
    name TEXT,
    decimals INTEGER,
    logo_url TEXT,
    last_updated TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    PRIMARY KEY (network, token_address)
);
```

#### Indexes
```sql
CREATE INDEX IF NOT EXISTS idx_token_metadata_cache_updated
  ON token_metadata_cache(network, last_updated);
```

---

### symbol_prices Table

Symbol-based price data table.

#### Schema
```sql
CREATE TABLE IF NOT EXISTS symbol_prices (
    symbol VARCHAR(50) PRIMARY KEY,
    price_usd NUMERIC(20, 8) NOT NULL,
    decimals INTEGER DEFAULT 18,
    name VARCHAR(100),
    last_updated BIGINT
);
```

#### Indexes
```sql
CREATE INDEX IF NOT EXISTS idx_symbol_prices_symbol
  ON symbol_prices(LOWER(symbol));
```

---

## Materialized View

### mv_distinct_contracts

Materialized View for hideUnnamed query optimization. Stores only the most recent first_seen record per contract_name.

#### Definition
```sql
CREATE MATERIALIZED VIEW mv_distinct_contracts AS
SELECT DISTINCT ON (contract_name)
  address,
  contract_name,
  deployed,
  fund,
  network,
  first_seen
FROM addresses
WHERE (tags IS NULL OR NOT 'EOA' = ANY(tags))
  AND contract_name IS NOT NULL
  AND contract_name != ''
ORDER BY contract_name, first_seen DESC NULLS LAST, fund DESC NULLS LAST, address ASC;
```

#### Indexes
```sql
-- For first_seen sort (default sort)
CREATE INDEX idx_mv_distinct_first_seen
  ON mv_distinct_contracts (first_seen DESC NULLS LAST);

-- For fund sort
CREATE INDEX idx_mv_distinct_fund
  ON mv_distinct_contracts (fund DESC NULLS LAST, deployed DESC NULLS LAST);

-- Network filter + first_seen sort
CREATE INDEX idx_mv_distinct_network_first_seen
  ON mv_distinct_contracts (network, first_seen DESC NULLS LAST);

-- Network filter + fund sort
CREATE INDEX idx_mv_distinct_network_fund
  ON mv_distinct_contracts (network, fund DESC NULLS LAST, deployed DESC NULLS LAST);
```

#### Characteristics
- **Row count**: ~6,535 (2.4% of total addresses table)
- **Refresh method**: Manual refresh (REFRESH MATERIALIZED VIEW)
- **Purpose**: Dedicated to hideUnnamed=true queries
- **Performance**: 1,880x speed improvement (188s â†’ 0.1s)

#### Refresh Methods
```sql
-- Regular refresh (table locking occurs)
REFRESH MATERIALIZED VIEW mv_distinct_contracts;

-- Concurrent refresh (no service interruption, recommended)
REFRESH MATERIALIZED VIEW CONCURRENTLY mv_distinct_contracts;
```

#### Automatic Refresh Schedule
```bash
# Crontab setup
# Auto-refresh daily at 3 AM
0 3 * * * sudo -u postgres psql -d bugchain_indexer -c "REFRESH MATERIALIZED VIEW CONCURRENTLY mv_distinct_contracts;" >> /var/log/mv_refresh.log 2>&1
```

---

## Partitioning Strategy

The addresses table is currently not partitioned. If data grows significantly in the future, partitioning by network or first_seen could be considered.

### Recommended Partitioning Strategy (Future)

#### Partitioning by Network
```sql
-- Parent table
CREATE TABLE addresses_partitioned (
    address VARCHAR(42),
    contract_name VARCHAR(255),
    deployed BIGINT,
    fund NUMERIC,
    network VARCHAR(50),
    first_seen BIGINT,
    tags TEXT[]
) PARTITION BY LIST (network);

-- Create partitions example
CREATE TABLE addresses_ethereum PARTITION OF addresses_partitioned
  FOR VALUES IN ('ethereum');

CREATE TABLE addresses_binance PARTITION OF addresses_partitioned
  FOR VALUES IN ('binance');

-- ... other networks
```

#### Advantages
- Improved query performance per network
- Reduced index size
- Ability to backup/restore specific networks only

#### Disadvantages
- Initial migration work required
- Need to create partition for new networks
- Increased complexity

---

## Query Patterns

### Basic Filtering Query
```sql
-- Network filter + first_seen sort
SELECT address, contract_name, deployed, fund, network, first_seen
FROM addresses
WHERE network = ANY(ARRAY['ethereum', 'binance'])
  AND (tags IS NULL OR NOT 'EOA' = ANY(tags))
ORDER BY first_seen DESC NULLS LAST
LIMIT 50;
```

### hideUnnamed Query (using Materialized View)
```sql
-- Unique records per contract_name, first_seen sort
SELECT address, contract_name, deployed, fund, network, first_seen
FROM mv_distinct_contracts
WHERE network = ANY(ARRAY['ethereum', 'binance'])
ORDER BY first_seen DESC NULLS LAST
LIMIT 50;
```

### COUNT Query
```sql
-- Total count (hideUnnamed=false)
SELECT COUNT(*) AS total
FROM addresses
WHERE (tags IS NULL OR NOT 'EOA' = ANY(tags));

-- Unique contract_name count (hideUnnamed=true)
SELECT COUNT(*) AS total
FROM mv_distinct_contracts
WHERE network = ANY(ARRAY['ethereum', 'binance']);
```

### Address Search
```sql
-- Exact match (fastest)
SELECT * FROM addresses WHERE address = '0x...';

-- Prefix search (10+ characters, index usable)
SELECT * FROM addresses WHERE address LIKE '0x742d35%';

-- Partial search (slow, full scan)
SELECT * FROM addresses WHERE address LIKE '%742d35%';
```

---

## Performance Optimization Tips

### VACUUM and ANALYZE
Regularly run VACUUM and ANALYZE to keep table statistics up-to-date.

```sql
-- Update statistics
ANALYZE addresses;
ANALYZE mv_distinct_contracts;

-- Clean dead tuples
VACUUM addresses;
VACUUM mv_distinct_contracts;

-- Full VACUUM (caution: time-consuming)
VACUUM FULL addresses;
```

### Automatic VACUUM Settings
```sql
-- Check current settings
SELECT relname, n_live_tup, n_dead_tup, last_autovacuum
FROM pg_stat_user_tables
WHERE relname IN ('addresses', 'mv_distinct_contracts');

-- Adjust autovacuum settings (if needed)
ALTER TABLE addresses SET (autovacuum_vacuum_scale_factor = 0.1);
ALTER TABLE addresses SET (autovacuum_analyze_scale_factor = 0.05);
```

### Index Rebuild
Rebuild indexes when they become bloated to improve performance.

```sql
-- Rebuild index (locking occurs)
REINDEX TABLE addresses;

-- Concurrent rebuild (no service interruption, recommended)
REINDEX INDEX CONCURRENTLY idx_addresses_first_seen_global;
```

---

## Backup and Restore

### Database Backup
```bash
# Full backup
pg_dump -U postgres bugchain_indexer > /backup/bugchain_indexer_$(date +%Y%m%d).sql

# Schema-only backup
pg_dump -U postgres -s bugchain_indexer > /backup/schema_only.sql

# addresses table only backup
pg_dump -U postgres -t addresses bugchain_indexer > /backup/addresses_only.sql
```

### Restore
```bash
# Full restore
psql -U postgres bugchain_indexer < /backup/bugchain_indexer_20251101.sql

# Specific table restore only
psql -U postgres bugchain_indexer < /backup/addresses_only.sql
```

### Materialized View Restore
After backup and restore, Materialized Views need to be recreated and refreshed.

```sql
-- Recreate MV (if not included in backup)
CREATE MATERIALIZED VIEW mv_distinct_contracts AS ...;

-- Fill data
REFRESH MATERIALIZED VIEW mv_distinct_contracts;

-- Recreate indexes
CREATE INDEX idx_mv_distinct_first_seen ON mv_distinct_contracts ...;
```

---

## Monitoring

### Table Size Monitoring
```sql
SELECT
  schemaname,
  tablename,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename)) AS total_size,
  pg_size_pretty(pg_relation_size(schemaname||'.'||tablename)) AS table_size,
  pg_size_pretty(pg_total_relation_size(schemaname||'.'||tablename) - pg_relation_size(schemaname||'.'||tablename)) AS index_size
FROM pg_tables
WHERE schemaname = 'public'
  AND tablename IN ('addresses')
ORDER BY pg_total_relation_size(schemaname||'.'||tablename) DESC;
```

### Query Performance Monitoring
```sql
-- Check slow queries (requires pg_stat_statements)
SELECT
  query,
  calls,
  total_exec_time,
  mean_exec_time,
  max_exec_time
FROM pg_stat_statements
WHERE query LIKE '%addresses%'
ORDER BY mean_exec_time DESC
LIMIT 10;

-- Currently running queries
SELECT
  pid,
  now() - query_start AS duration,
  state,
  query
FROM pg_stat_activity
WHERE state != 'idle'
  AND query LIKE '%addresses%'
ORDER BY duration DESC;
```

---

---

## Last Update

**Date**: 2025-11-01
**Version**: 2.0
**Changes**:
- Synchronized addresses table schema with actual implementation
- Added tokens, token_metadata_cache, symbol_prices tables
- Updated index list (based on ensureSchema)
- Reflected composite PRIMARY KEY (address, network)

---

## Related Documents
- [Project Structure](./project-structure.md)
- [API Performance Optimization](./api-performance-optimization.md)
- [Caching Strategy](./caching-strategy.md)
- [Materialized Views Details](./materialized-views.md)
